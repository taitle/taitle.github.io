<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Analysis of Ursnif Malware | </title>
<meta name="keywords" content="Malware Analysis, Reverse Engineering" />
<meta name="description" content="In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the Delivery, and Weaponization procedures.
Ursnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:
Dynamically importing functions from libraries Storing things encrypted Process Injection Corrupted PE headers Using .rdata to store encrypted payloads encrypted C2 communication Let&rsquo;s get started.">
<meta name="author" content="">
<link rel="canonical" href="https://ruysal.com/post/2020-11-26-Analysis-of-Ursnif-Malware/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.9f8e3ed56c0635e6e28d42eb7af576afe27c0395f1638f4539914b897ff327ac.css" integrity="sha256-n44&#43;1WwGNebijULrevV2r&#43;J8A5XxY49FOZFLiX/zJ6w=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ruysal.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ruysal.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ruysal.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ruysal.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://ruysal.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Analysis of Ursnif Malware" />
<meta property="og:description" content="In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the Delivery, and Weaponization procedures.
Ursnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:
Dynamically importing functions from libraries Storing things encrypted Process Injection Corrupted PE headers Using .rdata to store encrypted payloads encrypted C2 communication Let&rsquo;s get started." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ruysal.com/post/2020-11-26-Analysis-of-Ursnif-Malware/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-26T19:15:02&#43;00:00" />
<meta property="article:modified_time" content="2020-11-26T19:15:02&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analysis of Ursnif Malware"/>
<meta name="twitter:description" content="In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the Delivery, and Weaponization procedures.
Ursnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:
Dynamically importing functions from libraries Storing things encrypted Process Injection Corrupted PE headers Using .rdata to store encrypted payloads encrypted C2 communication Let&rsquo;s get started."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://ruysal.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Analysis of Ursnif Malware",
      "item": "https://ruysal.com/post/2020-11-26-Analysis-of-Ursnif-Malware/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Analysis of Ursnif Malware",
  "name": "Analysis of Ursnif Malware",
  "description": "In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the Delivery, and Weaponization procedures.\nUrsnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:\nDynamically importing functions from libraries Storing things encrypted Process Injection Corrupted PE headers Using .rdata to store encrypted payloads encrypted C2 communication Let\u0026rsquo;s get started.",
  "keywords": [
    "Malware Analysis", "Reverse Engineering"
  ],
  "articleBody": "In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the Delivery, and Weaponization procedures.\nUrsnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:\nDynamically importing functions from libraries Storing things encrypted Process Injection Corrupted PE headers Using .rdata to store encrypted payloads encrypted C2 communication Let’s get started.\nStatic Analysis Static analysis is the first step to get an idea of what we are up against. One of the first tools I use for this is PEStudio.\nThere are a few things we can infer from this:\nIt is a DLL file, and has no exported functions There are not many imported functions to reveal its functionality .rdata is bigger than .text section and it takes up almost half of the file’s total size. Next, let’s check some of the strings to see if we can find anything useful:\nThe pdb string looks unique to be an identifier for our sample. I’ve included it at the bottom of the post for further identification/detection purposes.\nFirst Execution Ursnif unpacks itself and delivers its payload in multiple stages. So, it would be easier to let it run once, observe its behavior with Procmon to get an overview of what it is doing, and try to follow the steps with the debugger next. The DLL can be executed with one of the following commands:\nrundll32 ursnif.dll, DllRegisterServer regsvr32.exe ursnif.dll Now, let’s examine the output from procmon. First, it seems like ursnif creates 2 threads. After those threads exit, a 3rd one is created. Within the 3rd thread, ursnif’s first stage payload is executed. A bit down below, this payload is analyzed in more detail.\nOne of the interesting things I noticed was that this payload is 296KB, whereas the DLL file itself (from which we started execution) is 790KB. This means that the first 2 threads do some sort of unpacking, and a 3rd thread is created with the unpacked executable.\n1st Stage - Mailslots Let’s start the analysis of the first 2 threads that we’ve seen on Procmon.\nI will use x32dbg to analyze this sample. Make sure that you are breaking on Thread Entry, which can be checked under your debugger’s preferences. Below you can see the entry of the first thread. Ursnif first obtains the current process id, which on my system is 0xFFC. It uses this PID to generate a name for the mailslot. On my environment, the mailslot’s name is: \\\\\\\\.\\\\mailslot\\\\slffc If like me, your first question was “wtf is a mailslot?”, it is, quoting from Wikipedia:\na one-way interprocess communication mechanism, available on the Microsoft Windows operating system, that allows communication between processes both locally and over a network.\nUrsnif utilizes mailslots to pass an executable between the two threads it creates. In the first thread, it calls CreateMailSlot, and then ReadFile with the handle of the previously created mailslot. If the call fails, it calls Sleep and tries again later.\nAt the second thread, it calls CreateFile with the handle of previously created mailslot. If CreateFile fails, ursnif calls Sleep and tries again in a while. The screenshot above is from the 2nd thread.\nIn the screenshot below, you can see a PE file with an erased header that ursnif writes. This will be inspected in detail at 2nd stage.\nUrsnif then calls WriteFile to copy the PE file in the memory to the mailslot. It writes 0x1000 bytes at a time. After the call, it sleeps for 64ms and then the routine above is repeated, until all of the file is written to the mailslot. The other thread calls ReadFile to retrieve the PE file and places it in the heap. After the routine finishes, the first 2 threads are killed and execution continues from the 3rd thread.\n2nd Stage After the first 2 threads are finished executing, the execution is handed over to the 3rd thread and we land on this piece of code: 002245E | FF7424 04 | push dword ptr ss:[esp+4] | 002245E | E8 F1F7FFFF | call 223DE2 | 002245F | B9 E4752200 | mov ecx,2275E4 | 002245F | 83CA FF | or edx,FFFFFFFF | 002245F | F0:0FC111 | lock xadd dword ptr ds:[ecx],edx | 002245F | C2 0400 | ret 4 | So everything we are looking for happens in this call. Since the first stage is unpacked, I wanted to check the Referenced Calls to see what the actual imported functions are:\nThe calls we see here are quite different than the ones we see at static analysis of 1st stage. The ones below are especially worth of note, as they are commonly used for Process Injection. There are also some calls to file and registry read/write APIs.\n\u003cntdll.ZwCreateSection\u003e \u003cntdll.ZwMapViewOfSection\u003e \u003cntdll.ZwUnmapViewOfSection\u003e \u003ckernel32.VirtualProtect\u003e \u003ckernel32.VirtualAlloc\u003e \u003ckernel32.SuspendThread\u003e \u003cadvapi32.RegSetValueExA\u003e While analyzing ursnif, you will constantly run into calls related to heap. I’ve seen some other posts detailing the way ursnif makes use of the heap, so I will skip that. Debuggers don’t do justice to keeping track of the heap, so this makes analysis a bit more challenging. The relevant calls can be seen in the list of referenced calls:\n\u003ckernel32.HeapCreate\u003e \u003ckernel32.HeapFree\u003e \u003cntdll.RtlAllocateHeap\u003e At this point, I wanted to check where we are executing from, and whether we could dump the executed module. The dumped file is 296kb, whereas the original sample was 790kb. As can be seen below, ursnif corrupts the PE headers (the one that was written mentioned earlier), which makes it evade automated dumping.\nUpon execution, one of the first things ursnif does is checking the file C_1252NLS under System32. The reason for this is stated in the leaked Gozi/ISFB loader as:\nOpening c_1252.nls file and getting it’s write time.\nThus we can determine a time when OS was installed.\nSource: windows/gozi-isfb/install.c#L112\nAlthough ursnif is based on the leaked source code, it is modified and constantly updated. However, this behavior seems to have been persisting, so it can be used as a unique identifier.\nAfter this, within the same function call, Ursnif “generates module names”. By this I mean the name of the DLL file to be dropped, and the name of the autorun key to execute that DLL file. This routine as well is present in the leaked Gozi-ISFB source code. You can check out the relevant source code by the following links:\nGenModuleName: windows/gozi-isfb/install.c#L87\nSetAutoRun: windows/gozi-isfb/install.c#L228\nThis is added to the list of unique identifiers as well.\nAt the end of this routine, on my system the generated names for the dll and folder are:\n002241F | BF D0762200 | mov edi,2276D0 | 2276D0:\u0026L\"blb_OMEX\";this is the key name for autorun 00222F1 | 8B45 08 | mov eax,dword ptr ss:[ebp+8] | [ebp+8]:\u0026\"ddraWNet\";folder name to be created under %appdata%\\Microsoft\\ After this, the following key is acquired. This is important, as ursnif drops some important keys under here.\n00223BD | A3 DC762200 | mov dword ptr ds:[2276DC],eax | eax:\"Software\\\\AppDataLow\\\\Software\\\\Microsoft\\\\FD56FF74-382C-3782-2A81-EC5BFE45E0BF\" And the name of the DLL file to be dropped under %appdata% is copied:\n00223F1 | FF35 D47622 | push dword ptr ds:[2276D4] | 002276D4:\u0026L\"bcdpbres.dll\" To spare some details, I will accompany some of the important calls with procmon logs. That way we can just look at the end results and where the calls have originated from.\n002C508 | FF15 34602C | call dword ptr ds:[\u003c\u0026RegOpenKeyExA\u003e] | Procmon Log: 5:39:47.2296762 AM\trundll32.exe\t2800\tRegOpenKey\tHKU\tSUCCESS\tDesired Access: Maximum Allowed, Granted Access: All Access 002C50D | FF15 08602C | call dword ptr ds:[\u003c\u0026RegEnumKeyExA\u003e] | 002C512 | E8 69D4FFFF | call 2C2599 |;we have to dive into one more call After here, we dive into the call and follow the steps from there:\n002C266 | 8B35 38602C | mov esi,dword ptr ds:[\u003c\u0026RegQueryValueExW | 002C267 | FFD6 | call esi | Procmon Logs: 5:46:50.8931454 AM\trundll32.exe\t2800\tRegQueryValue\tHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\AppData\tSUCCESS\tType: REG_SZ, Length: 64, Data: C:\\Users\\IEUser\\AppData\\Roaming 5:59:07.4587868 AM\trundll32.exe\t2800\tRegQueryValue\tHKU\\S-1-5-21-3583694148-1414552638-2922671848-1002\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\AppData\tNAME NOT FOUND\tLength: 144 This is done to acquire the %appdata% path for each user account to be infected. A call to PathCombineW is made to append \\Microsoft to absolute path of appdata. The previously generated system specific directory (in my case ddraWNet) is created at this location.\nHere, ursnif checks whether it is being executed from the dropped location under appdata. If it does, it skips the rest of the function because this would mean the payload has already been executed once, and there is no need to drop itself again.\n002C271 | FF35 08762C | push dword ptr ds:[2C7608] | 002C7608:\u0026L\"C:\\\\Users\\\\IEUser\\\\Desktop\\\\sample\\\\75a86f64c1ab7d8a56532b793a8547b7.dll\" 002C271 | 57 | push edi | edi:L\"C:\\\\Users\\\\IEUser\\\\AppData\\\\Roaming\\\\Microsoft\\\\DdraWNet\\\\bcdpbres.dll\" 002C271 | FF15 6C602C | call dword ptr ds:[\u003c\u0026lstrcmpiW\u003e] | 002C272 | 85C0 | test eax,eax | eax:L\"C:\\\\Users\\\\IEUser\\\\AppData\\\\Roaming\\\\Microsoft\\\\DdraWNet\\\\bcdpbres.dll\" 002C272 | 0F84 D80100 | je 2C2902 | Since this is our first run, we don’t take the jump and continue to this:\n002C486 | 8B35 34612C | mov esi,dword ptr ds:[\u003c\u0026WriteFile\u003e] | 002C48A | FFD6 | call esi | 002C48B | FF15 2C612C | call dword ptr ds:[\u003c\u0026SetEndOfFile\u003e] | 002C490 | FF15 38612C | call dword ptr ds:[\u003c\u0026FlushFileBuffers\u003e] | Now the sample has dropped itself on disk. The dropped one is the same as the one we started the execution from(790KB). Since DdraWNet\\\\bcdpbres.dll will be added to startup under Run key, and it is the main loader, this means in each startup, it will unpack itself, inject itself to another process, and continue execution from there.\n002C27B | FF75 1C | push dword ptr ss:[ebp+1C] | [ebp+1C]:L\"rundll32 \\\"C:\\\\Users\\\\IEUser\\\\AppData\\\\Roaming\\\\Microsoft\\\\DdraWNet\\\\bcdpbres.dll\\\",DllRegisterServer\" 002C27C | FF15 BC602C | call dword ptr ds:[\u003c\u0026lstrcpy\u003e] | 002C27D | 50 | push eax | eax:\"Software\\\\AppDataLow\\\\Software\\\\Microsoft\\\\FD56FF74-382C-3782-2A81-EC5BFE45E0BF\" 002C27D | FF15 20602C | call dword ptr ds:[\u003c\u0026RegCreateKeyA\u003e] | 002C280 | FF15 1C602C | call dword ptr ds:[\u003c\u0026RegQueryValueExA\u003e] | 6:52:26.0547460 AM\trundll32.exe\t2800\tRegSetValue\tHKCU\\Software\\AppDataLow\\Software\\Microsoft\\FD56FF74-382C-3782-2A81-EC5BFE45E0BF\\Client32\tSUCCESS\tType: REG_BINARY, Length: 204,288, Data: 96 F8 2A 18 2F F1 C5 2F C9 E9 60 47 5E E2 FC 5E Here ursnif sets a few keys under AppDataLow for persistency.\nAfter this, every string that was stored in the heap is released. These include the names of the registry keys, appdata, dropped DLL’s name etc. Like mentioned before, ursnif tries to retrieve things dynamically as much as possible. At the end of the routine, it releases the heap memory. This leaves us with a very narrow window to peek into the strings.\nAfter it copies itself under %appdata% and drops the keys at appdatalow key, ursnif attempts to delete itself. If it fails, it calls MoveFileExW with the argument 0x4, which according to Microsoft’s documentation corresponds to MOVEFILE_DELAY_UNTIL_REBOOT. Quoting from the documentation:\nThe system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files.\nSince this is the file we are currently executing from, DeleteFileW will fail and it will do this operation after the reboot.\nProcess Injection Ursnif then calls a function to perform process injection.\nInside this function, a call is made to the RtlGetNativeSystemInformation API. Among other things, this is used to retrieve a list of running processes on the system.\nesi holds the address to the struct to be filled, which can be seen in the dump. Inside 381A3D, a call is made to 002C346A, which contains the process injection routine. This function takes the struct shown above as an argument.\nThe above checks one of the struct members got from the undocumented call and if it is 0, it jumps to the end of the routine. ursnif uses this struct to retrieve a list of the running processes. It then enumerates these processes one by one, calculates the checksum of each process’ name, and compares them against the precalculated ones:\n002C34B | 3D 121725AC | cmp eax,AC251712 | 002C34B | 74 47 | je 2C3504 | 002C34B | 3D 8A8EFE58 | cmp eax,58FE8E8A | 002C34C | 74 40 | je 2C3504 | 002C34C | 3D 65496DA7 | cmp eax,A76D4965 | 002C34C | 74 39 | je 2C3504 | 002C34C | 3D 12D72C96 | cmp eax,962CD712 | 002C34D | 74 32 | je 2C3504 | 002C34D | 3D F5BBE0A6 | cmp eax,A6E0BBF5 |;explorer.exe 002C34D | 75 36 | jne 2C350F | After looping through the process list, ursnif finally reaches explorer.exe, whose value corresponds to A6E0BBF5. I did not confirm this, but based on what I’ve seen on other reports for this family, one of the other values might be for svchost.exe.\nThe jump takes us to another function call, which lets ursnif inject itself into explorer.exe. I was curious where the other jumps above would lead us to, and one of them seems to create a process. My guess is that if it does not find a suitable process to be injected, it creates one for itself. Continuing, ursnif calls OpenProcess to acquire a handle to explorer.exe. Then it makes a call to GetProcAddress with the handle of explorer.exe to get the address of ntdll.RtlExitUserThread.\nNext, it calls GetProcAddress again. This time to get the address of CreateRemoteThread. And then, it calls CreateRemoteThread, with the LPTHREAD_START_ROUTINE lpStartAddress of ntdll.RtlExitUserThread. So, the injected thread will start executing from RtlExitUserThread. The thread is also created in suspended state.\nAfter the thread is created, ursnif calls ZwReadVirtualMemory to read the first 4 bytes from the created thread’s EIP. These 4 bytes are saved in a buffer. Ursnif then calls VirtualProtectEx to make the page from RtlExitUserThread writable. It uses ZwWriteVirtualMemory to write the bytes EB FE CC CC to the buffer, and resumes the thread.\nEB FE is quite a famous piece of opcode. It is an infinite loop, achieved by a relative short jump. Since short jumps takes 2 bytes, by jumping back 2 bytes, an infinite loop can be created. After the infinite loop, the next two bytes are CC CC, which are used for software breakpoints (more specifically, debug exception handler).\nTo sum up:\nUrsnif acquires a handle to explorer.exe From explorer.exe, gets address of ntdll.RtlExitUserThread Creates a suspended thread with EP set to ntdll.RtlExitUserThread Reads the first 4 bytes from the thread Replaces the first 4 bytes from EP with EBFECCCC, which creates an infinite loop After seeing the disassembly for this function, I’ve checked some of the material published on this malware family. In the blog referred below, the behavior listed above is described in pseudo-code.\nhttps://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/\n/* source link above, copied from arielkoren.com /* Obtain the process pid to inject to */ dwPID = GetInjectProcess() hProcess = OpenProcess(dwPID, ...) pAddress = GetProcAddress(\"ntdll.dll\", \"RtlExitUserThread\") /* Create remote thread in suspended mode */ hThread = CreateRemoteThread(hProcess, /* Remote process handle */ CREATE_SUSPENDED,\t/* creation flags */ pAddress,\t/* thread function address */ ...) /* Read remote procedure first four bytes */ dwBackupData = ZwReadVirtualMemory(hProcess,\t/* Remote process handle */ pAddress,\t/* Address to read */ 4,\t/* number of bytes to read */ ...) /* Change address protection to `writable` */ VirtualProtectEx(hProcess,\t/* Remote process handle */ READ_WRITE_EXECUTE,\t/* New protection flags */ pAddress,\t/* Address to change protection on */ 4,\t/* Size of address */ ...) ZwWriteVirtualMemory(hProcess,\t/* Remote process handle */ pAddress,\t/* Address to overwrite */ 0xCCCCFEEB,\t/* Data to write */ 4,\t/* Size of data */ ...) During my first analysis of ursnif, I noticed that a couple of seconds into the execution, CPU usage spiked to quite a high level, and the environment became almost unresponsive for a moment.\nLooking at the screenshot below, I realized why. Since ursnif writes infinite loop at the entry point of RtlExitUserThread, whenever a user thread exited during this stage, it started running the infinite loop. This caused several threads to be in an infinite loop, draining a lof of CPU time. You can see that at least 4 threads have their EIP pointed at the infinite loop. However, only one of the threads’ EP points to the infinite loop, and it is suspended.\nAfter this, ursnif resumes the thread for a short period for initialization, and suspends again. It calls NtGetContextThread, and uses the returned struct to modify the entry point of the thread. During the following routine, it calls\nZwCreateSection ZwMapViewOfSection GetModuleHandleA GetModuleFileNameW And then it uses these to retrieve addresses of LdrLoadDll, LdrGetProcedureAddress, and ZwProtectVirtualMemory. Ursnif then calls ZwAllocateVirtualMemory to allocate memory in explorer.exe’s address space. In the screenshot below, the allocated address is 01FD0000, and allocated space is 0x1000 bytes big.\nUrsnif then copies the payload to explorer’s address space. In the screenshot below, the payload can be seen in dump: The disassembly of the payload looks like this:\n01A193E | 8B48 08 | mov ecx,dword ptr ds:[eax+8] | 01A193E | FF70 10 | push dword ptr ds:[eax+10] | 01A193E | FF30 | push dword ptr ds:[eax] | 01A193E | 51 | push ecx | 01A193E | C3 | ret | Since there is a ret to push, we will have to wait until the thread is executed to see where we will jump.\nUrsnif then calls ZwUnmapViewofSection on a region with the size of 0x68000. The section contains a 416KB PE file with erased header.\nContinuing, ursnif calls ZwWriteVirtualMemory with the address of previously allocated space in explorer.exe, 01FD0000, and the payload shown above.\nThen ursnif calls ZwSetContextThread, with the new EIP written into the context. In the screenshot below, new EIP can be seen as 01FD0218. Now we can attach to explorer.exe, set our breakpoint there, and let explorer.exe continue its execution. Ursnif calls ZwWriteVirtualMemory again, this time to restore the previously overwritten 4 bytes; EB FE CC CC. It then calls VirtualProtectEx to restore the page rights. After this, process injection routine is finished, and ursnif calls ResumeThread.\nexplorer.exe Immediately, our breakpoint at 01A193E is triggered. The push ecx, ret routine takes the execution to another memory region, with the size 0x68000 (416KB). This is the PE file with erased header, previously used with ZwUnmapViewOfSection.\nAt this point, the analysis has become another side project that’s waiting to see the light of day again. So that’s it for this post. Who knows, maybe I can publish part 2 of this one day.\nIOC MD5: 75a86f64c1ab7d8a56532b793a8547b7 SHA256: 0f06bc2f24494d9206d8d985f0a2f13ec6975a225c0bdcbab6d7f74474ff70a6 File Access: c:\\windows\\system32\\c_1252.nls PDB String: c:\\\\path\\\\Know\\\\School\\\\Rest\\\\sing\\\\Pick\\\\officerun.pdb File Write: %appdata%/Roaming/-RandomName-/-RandomName-.dll Registry Write: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run Registry Write: HKCU\\Software\\AppDataLow\\Software\\Microsoft\\{GUID} File Write: %temp%/[A-Fa-f0-9]{4}.bin Network Data Format(Before Encryption): soft=%u\u0026version=%u\u0026user=%08x%08x%08x%08x\u0026server=%u\u0026id=%u\u0026crc=%x Network Data Format(After Encryption): images/[encryted_data]/.[extension] References and Further Reading https://forums.juniper.net/t5/Threat-Research/The-Gozi-Sleeper-Cell/ba-p/329691\nhttps://www.vmray.com/cyber-security-blog/analyzing-ursnif-behavior-malware-sandbox/\nhttps://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/\nhttps://www.netskope.com/blog/ursnif-data-theft-malware-shared-on-microsoft-onedrive\nhttps://www.mbsd.jp/blog/20180607.html\n",
  "wordCount" : "3062",
  "inLanguage": "en",
  "datePublished": "2020-11-26T19:15:02Z",
  "dateModified": "2020-11-26T19:15:02Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ruysal.com/post/2020-11-26-Analysis-of-Ursnif-Malware/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ruysal.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" text>
                    
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>Dark/Light
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ruysal.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ruysal.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Analysis of Ursnif Malware
    </h1>
    <div class="post-meta"><span title='2020-11-26 19:15:02 +0000 UTC'>November 26, 2020</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#static-analysis-a-namestaticanalysisa" aria-label="Static Analysis ">Static Analysis <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#first-execution-a-namefirstexecutiona" aria-label="First Execution ">First Execution <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#1st-stage---mailslotsa-name1ststagea" aria-label="1st Stage - Mailslots">1st Stage - Mailslots<!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#2nd-stage-a-name2ndstagea" aria-label="2nd Stage ">2nd Stage <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#process-injection-a-nameprocessinjectiona" aria-label="Process Injection ">Process Injection <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#explorerexe-a-nameexplorera" aria-label="explorer.exe ">explorer.exe <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#ioc-a-nameidentifiersa" aria-label="IOC ">IOC <!-- raw HTML omitted --><!-- raw HTML omitted --></a></li>
                <li>
                    <a href="#references-and-further-reading-a-namereferencesa" aria-label="References and Further Reading ">References and Further Reading <!-- raw HTML omitted --><!-- raw HTML omitted --></a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>In this post, I will document my analysis of a malware sample from the Ursnif family. The analysis is only concerned with dissecting the DLL sample, and not the <code>Delivery</code>, and <code>Weaponization</code> procedures.</p>
<p>Ursnif employs quite a few tricks to make the analysis more challenging and hide itself from intruding eyes, such as:</p>
<ul>
<li>Dynamically importing functions from libraries</li>
<li>Storing things encrypted</li>
<li>Process Injection</li>
<li>Corrupted PE headers</li>
<li>Using .rdata to store encrypted payloads</li>
<li>encrypted C2 communication</li>
</ul>
<p>Let&rsquo;s get started.</p>
<h2 id="static-analysis-a-namestaticanalysisa">Static Analysis <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#static-analysis-a-namestaticanalysisa">#</a></h2>
<p>Static analysis is the first step to get an idea of what we are up against. One of the first tools I use for this is <code>PEStudio</code>.</p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="/assets/img/ursnif/2-pestudio-sections.png" alt="Sections"  />
</p>
<p>There are a few things we can infer from this:</p>
<ul>
<li>It is a DLL file, and has no exported functions</li>
<li>There are not many imported functions to reveal its functionality</li>
<li>.rdata is bigger than .text section and it takes up almost half of the file&rsquo;s total size.</li>
</ul>
<p>Next, let&rsquo;s check some of the strings to see if we can find anything useful:</p>
<p><img loading="lazy" src="/assets/img/ursnif/4-strings.png" alt="Strings"  />
</p>
<p>The pdb string looks unique to be an identifier for our sample. I&rsquo;ve included it <a href="#identifiers">at the bottom of the post</a> for further identification/detection purposes.</p>
<h2 id="first-execution-a-namefirstexecutiona">First Execution <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#first-execution-a-namefirstexecutiona">#</a></h2>
<p>Ursnif unpacks itself and delivers its payload in multiple stages. So, it would be easier to let it run once, observe its behavior with <code>Procmon</code> to get an overview of what it is doing, and try to follow the steps with the debugger next. The DLL can be executed with one of the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>rundll32 ursnif.dll, DllRegisterServer
</span></span><span style="display:flex;"><span>regsvr32.exe ursnif.dll
</span></span></code></pre></div><p>Now, let&rsquo;s examine the output from procmon.
<img loading="lazy" src="/assets/img/ursnif/5-procmon.png" alt="procmon"  />
</p>
<p>First, it seems like ursnif creates 2 threads. After those threads exit, a 3rd one is created. Within the 3rd thread, ursnif&rsquo;s first stage payload is executed. A bit down below, this payload is analyzed in more detail.</p>
<p>One of the interesting things I noticed was that this payload is 296KB, whereas the DLL file itself (from which we started execution) is 790KB.
This means that the first 2 threads do some sort of unpacking, and a 3rd thread is created with the unpacked executable.</p>
<h2 id="1st-stage---mailslotsa-name1ststagea">1st Stage - Mailslots<!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#1st-stage---mailslotsa-name1ststagea">#</a></h2>
<p>Let&rsquo;s start the analysis of the first 2 threads that we&rsquo;ve seen on Procmon.</p>
<p>I will use x32dbg to analyze this sample. Make sure that you are breaking on <code>Thread Entry</code>, which can be checked under your debugger&rsquo;s preferences.
Below you can see the entry of the first thread. Ursnif first obtains the current process id, which on my system is <code>0xFFC</code>. It uses this PID to generate a name for the mailslot. On my environment, the mailslot&rsquo;s name is: <code>\\\\.\\mailslot\\slffc</code>
<img loading="lazy" src="/assets/img/ursnif/00-first.png" alt="firstthread"  />
</p>
<p>If like me, your first question was &ldquo;wtf is a mailslot?&rdquo;, it is, quoting from <a href="https://en.wikipedia.org/wiki/MailSlot">Wikipedia</a>:</p>
<blockquote>
<p>a one-way interprocess communication mechanism, available on the Microsoft Windows operating system, that allows communication between processes both locally and over a network.</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/ursnif/01-2ndthread.png" alt="secondthread"  />

Ursnif utilizes mailslots to pass an executable between the two threads it creates. In the first thread, it calls <code>CreateMailSlot</code>, and then <code>ReadFile</code> with the handle of the previously created mailslot. If the call fails, it calls <code>Sleep</code> and tries again later.</p>
<p>At the second thread, it calls <code>CreateFile</code> with the handle of previously created mailslot. If <code>CreateFile</code> fails, ursnif calls <code>Sleep</code> and tries again in a while. The screenshot above is from the 2nd thread.</p>
<p>In the screenshot below, you can see a PE file with an erased header that ursnif writes. This will be inspected in detail at 2nd stage.</p>
<p>Ursnif then calls <code>WriteFile</code> to copy the PE file in the memory to the mailslot. It writes <code>0x1000</code> bytes at a time. After the call, it sleeps for <code>64ms</code> and then the routine above is repeated, until all of the file is written to the mailslot.
<img loading="lazy" src="/assets/img/ursnif/02-pe.png" alt="secondthread"  />
</p>
<p>The other thread calls <code>ReadFile</code> to retrieve the PE file and places it in the <code>heap</code>. After the routine finishes, the first 2 threads are killed and execution continues from the 3rd thread.</p>
<h2 id="2nd-stage-a-name2ndstagea">2nd Stage <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#2nd-stage-a-name2ndstagea">#</a></h2>
<p>After the first 2 threads are finished executing, the execution is handed over to the 3rd thread and we land on this piece of code:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">|</span> FF7424 <span style="color:#ae81ff">04</span>   <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ss:[esp<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>]                    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">|</span> E8 F1F7FFFF <span style="color:#f92672">|</span> call <span style="color:#ae81ff">223</span>DE2                                  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">F</span> <span style="color:#f92672">|</span> B9 E4752200 <span style="color:#f92672">|</span> mov ecx,<span style="color:#ae81ff">2275</span>E4                               <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">F</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">83</span>CA FF     <span style="color:#f92672">|</span> or edx,FFFFFFFF                              <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">F</span> <span style="color:#f92672">|</span> F0:<span style="color:#ae81ff">0</span>FC111   <span style="color:#f92672">|</span> lock xadd <span style="color:#66d9ef">dword</span> ptr ds:[ecx],edx             <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002245</span><span style="color:#a6e22e">F</span> <span style="color:#f92672">|</span> C2 <span style="color:#ae81ff">0400</span>     <span style="color:#f92672">|</span> ret <span style="color:#ae81ff">4</span>                                        <span style="color:#f92672">|</span></span></span></code></pre></div>
So everything we are looking for happens in this call. Since the first stage is unpacked, I wanted to check the Referenced Calls to see what the actual imported functions are:</p>
<p><img loading="lazy" src="/assets/img/ursnif/6-firstthreadcalls.png" alt="referencedcalls"  />
</p>
<p>The calls we see here are quite different than the ones we see at static analysis of 1st stage. The ones below are especially worth of note, as they are commonly used for <code>Process Injection</code>. There are also some calls to file and registry read/write APIs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">ntdll.ZwCreateSection</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">ntdll.ZwMapViewOfSection</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">ntdll.ZwUnmapViewOfSection</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">kernel32.VirtualProtect</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">kernel32.VirtualAlloc</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">kernel32.SuspendThread</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">advapi32.RegSetValueExA</span><span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>While analyzing ursnif, you will constantly run into calls related to <code>heap</code>. I&rsquo;ve seen some other posts detailing the way ursnif makes use of the heap, so I will skip that. Debuggers don&rsquo;t do justice to keeping track of the heap, so this makes analysis a bit more challenging. The relevant calls can be seen in the list of referenced calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">kernel32.HeapCreate</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">kernel32.HeapFree</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">ntdll.RtlAllocateHeap</span><span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>At this point, I wanted to check where we are executing from, and whether we could dump the executed module. The dumped file is 296kb, whereas the original sample was 790kb. As can be seen below, ursnif corrupts the PE headers (the one that was written mentioned earlier), which makes it evade automated dumping.</p>
<p><img loading="lazy" src="/assets/img/ursnif/8-pe-firststage.png" alt="peheader"  />
</p>
<p>Upon execution, one of the first things ursnif does is checking the file <code>C_1252NLS</code> under <code>System32</code>. The reason for this is stated in the leaked <code>Gozi/ISFB</code> loader as:</p>
<blockquote>
<p>Opening c_1252.nls file and getting it&rsquo;s write time.</p>
<p>Thus we can determine a time when OS was installed.</p>
<p>Source: <a href="https://github.com/gbrindisi/malware/blob/master/windows/gozi-isfb/install.c#L112">windows/gozi-isfb/install.c#L112</a></p>
</blockquote>
<p><img loading="lazy" src="/assets/img/ursnif/7-c1252.png" alt="c1252"  />
</p>
<p>Although ursnif is based on the leaked source code, it is modified and constantly updated. However, this behavior seems to have been persisting, so it can be used as a <a href="#identifiers">unique identifier</a>.</p>
<p>After this, within the same function call, Ursnif &ldquo;generates module names&rdquo;. By this I mean the name of the DLL file to be dropped, and the name of the autorun key to execute that DLL file. This routine as well is present in the leaked Gozi-ISFB source code. You can check out the relevant source code by the following links:</p>
<blockquote>
<p><a href="https://github.com/gbrindisi/malware/blob/667b44f64edcd1c5e8c42489b8e767813a589158/windows/gozi-isfb/install.c#L87">GenModuleName: windows/gozi-isfb/install.c#L87</a></p>
<p><a href="https://github.com/gbrindisi/malware/blob/667b44f64edcd1c5e8c42489b8e767813a589158/windows/gozi-isfb/install.c#L228">SetAutoRun: windows/gozi-isfb/install.c#L228</a></p>
</blockquote>
<p>This is added to the list of <a href="#identifiers">unique identifiers</a> as well.</p>
<p>At the end of this routine, on my system the generated names for the dll and folder are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002241</span><span style="color:#a6e22e">F</span> <span style="color:#f92672">|</span> BF D0762200 <span style="color:#f92672">|</span> mov edi,<span style="color:#ae81ff">2276</span>D0                           <span style="color:#f92672">|</span> <span style="color:#ae81ff">2276</span>D0:<span style="color:#f92672">&amp;</span>L<span style="color:#e6db74">&#34;blb_OMEX&#34;</span><span style="color:#75715e">;this is the key name for autorun</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">00222</span><span style="color:#a6e22e">F1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">8</span>B45 <span style="color:#ae81ff">08</span>     <span style="color:#f92672">|</span> mov eax,<span style="color:#66d9ef">dword</span> ptr ss:[ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>]             <span style="color:#f92672">|</span> [ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>]:<span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;ddraWNet&#34;</span><span style="color:#75715e">;folder name to be created under %appdata%\Microsoft\</span>
</span></span></code></pre></div><p>After this, the following key is acquired. This is important, as ursnif drops some important keys under here.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">00223</span><span style="color:#a6e22e">BD</span> <span style="color:#f92672">|</span> A3 DC762200 <span style="color:#f92672">|</span> mov <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#ae81ff">2276</span>DC],eax            <span style="color:#f92672">|</span> eax:<span style="color:#e6db74">&#34;Software\\AppDataLow\\Software\\Microsoft\\FD56FF74-382C-3782-2A81-EC5BFE45E0BF&#34;</span>
</span></span></code></pre></div><p>And the name of the DLL file to be dropped under %appdata% is copied:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">00223</span><span style="color:#a6e22e">F1</span> <span style="color:#f92672">|</span> FF35 D47622 <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#ae81ff">2276</span>D4]               <span style="color:#f92672">|</span> <span style="color:#ae81ff">002276</span>D4:<span style="color:#f92672">&amp;</span>L<span style="color:#e6db74">&#34;bcdpbres.dll&#34;</span>
</span></span></code></pre></div><p>To spare some details, I will accompany some of the important calls with procmon logs. That way we can just look at the end results and where the calls have originated from.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C508</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">34602</span>C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>RegOpenKeyExA<span style="color:#f92672">&gt;</span>]     <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Procmon</span> Log: <span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">39</span>:<span style="color:#ae81ff">47.2296762</span> AM	rundll32.exe	<span style="color:#ae81ff">2800</span>	RegOpenKey	HKU	SUCCESS	Desired Access: Maximum Allowed, Granted Access: All Access
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C50D</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">08602</span>C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>RegEnumKeyExA<span style="color:#f92672">&gt;</span>]     <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C512</span> <span style="color:#f92672">|</span> E8 <span style="color:#ae81ff">69</span>D4FFFF <span style="color:#f92672">|</span> call <span style="color:#ae81ff">2</span>C2599                              <span style="color:#f92672">|</span><span style="color:#75715e">;we have to dive into one more call</span>
</span></span></code></pre></div><p>After here, we dive into the call and follow the steps from there:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C266</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">8</span>B35 <span style="color:#ae81ff">38602</span>C <span style="color:#f92672">|</span> mov esi,<span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>RegQueryValueExW <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C267</span> <span style="color:#f92672">|</span> FFD6        <span style="color:#f92672">|</span> call esi                                 <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Procmon</span> Logs:
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">5:46:50</span><span style="color:#a6e22e">.8931454</span> AM	rundll32.exe	<span style="color:#ae81ff">2800</span>	RegQueryValue	HKCU<span style="color:#960050;background-color:#1e0010">\</span>Software<span style="color:#960050;background-color:#1e0010">\</span>Microsoft<span style="color:#960050;background-color:#1e0010">\</span>Windows<span style="color:#960050;background-color:#1e0010">\</span>CurrentVersion<span style="color:#960050;background-color:#1e0010">\</span>Explorer<span style="color:#960050;background-color:#1e0010">\</span>Shell Folders<span style="color:#960050;background-color:#1e0010">\</span>AppData	SUCCESS	Type: REG_SZ, Length: <span style="color:#ae81ff">64</span>, Data: C:<span style="color:#960050;background-color:#1e0010">\</span>Users<span style="color:#960050;background-color:#1e0010">\</span>IEUser<span style="color:#960050;background-color:#1e0010">\</span>AppData<span style="color:#960050;background-color:#1e0010">\</span>Roaming
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">5:59:07</span><span style="color:#a6e22e">.4587868</span> AM	rundll32.exe	<span style="color:#ae81ff">2800</span>	RegQueryValue	HKU<span style="color:#960050;background-color:#1e0010">\</span>S<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span><span style="color:#f92672">-</span><span style="color:#ae81ff">21</span><span style="color:#f92672">-</span><span style="color:#ae81ff">3583694148</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1414552638</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2922671848</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1002</span><span style="color:#960050;background-color:#1e0010">\</span>Software<span style="color:#960050;background-color:#1e0010">\</span>Microsoft<span style="color:#960050;background-color:#1e0010">\</span>Windows<span style="color:#960050;background-color:#1e0010">\</span>CurrentVersion<span style="color:#960050;background-color:#1e0010">\</span>Explorer<span style="color:#960050;background-color:#1e0010">\</span>Shell Folders<span style="color:#960050;background-color:#1e0010">\</span>AppData	NAME NOT FOUND	Length: <span style="color:#ae81ff">144</span>
</span></span></code></pre></div><p>This is done to acquire the <code>%appdata%</code> path for each user account to be infected. A call to <code>PathCombineW</code> is made to append <code>\Microsoft</code> to absolute path of appdata. The previously generated system specific directory (in my case <code>ddraWNet</code>) is created at this location.</p>
<p>Here, ursnif checks whether it is being executed from the dropped location under appdata. If it does, it skips the rest of the function because this would mean the payload has already been executed once, and there is no need to drop itself again.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C271</span> <span style="color:#f92672">|</span> FF35 <span style="color:#ae81ff">08762</span>C <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#ae81ff">2</span>C7608]                 <span style="color:#f92672">|</span> <span style="color:#ae81ff">002</span>C7608:<span style="color:#f92672">&amp;</span>L<span style="color:#e6db74">&#34;C:\\Users\\IEUser\\Desktop\\sample\\75a86f64c1ab7d8a56532b793a8547b7.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C271</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">57</span>          <span style="color:#f92672">|</span> push edi                                   <span style="color:#f92672">|</span> edi:L<span style="color:#e6db74">&#34;C:\\Users\\IEUser\\AppData\\Roaming\\Microsoft\\DdraWNet\\bcdpbres.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C271</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">6</span>C602C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>lstrcmpiW<span style="color:#f92672">&gt;</span>]           <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C272</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">85</span>C0        <span style="color:#f92672">|</span> test eax,eax                               <span style="color:#f92672">|</span> eax:L<span style="color:#e6db74">&#34;C:\\Users\\IEUser\\AppData\\Roaming\\Microsoft\\DdraWNet\\bcdpbres.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C272</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0</span>F84 D80100 <span style="color:#f92672">|</span> je <span style="color:#ae81ff">2</span>C2902                                  <span style="color:#f92672">|</span>
</span></span></code></pre></div><p>Since this is our first run, we don&rsquo;t take the jump and continue to this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C486</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">8</span>B35 <span style="color:#ae81ff">34612</span>C <span style="color:#f92672">|</span> mov esi,<span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>WriteFile<span style="color:#f92672">&gt;</span>]        <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C48A</span> <span style="color:#f92672">|</span> FFD6        <span style="color:#f92672">|</span> call esi                                   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C48B</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">2</span>C612C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>SetEndOfFile<span style="color:#f92672">&gt;</span>]        <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C490</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">38612</span>C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>FlushFileBuffers<span style="color:#f92672">&gt;</span>]    <span style="color:#f92672">|</span>
</span></span></code></pre></div><p>Now the sample has dropped itself on disk. The dropped one is the same as the one we started the execution from(790KB). Since <code>DdraWNet\\bcdpbres.dll</code> will be added to startup under <code>Run</code> key, and it is the main loader, this means in each startup, it will unpack itself, inject itself to another process, and continue execution from there.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C27B</span> <span style="color:#f92672">|</span> FF75 <span style="color:#ae81ff">1</span>C     <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ss:[ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>C]                 <span style="color:#f92672">|</span> [ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>C]:L<span style="color:#e6db74">&#34;rundll32 \&#34;C:\\Users\\IEUser\\AppData\\Roaming\\Microsoft\\DdraWNet\\bcdpbres.dll\&#34;,DllRegisterServer&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C27C</span> <span style="color:#f92672">|</span> FF15 BC602C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>lstrcpy<span style="color:#f92672">&gt;</span>]             <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C27D</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">50</span>          <span style="color:#f92672">|</span> push eax                                   <span style="color:#f92672">|</span> eax:<span style="color:#e6db74">&#34;Software\\AppDataLow\\Software\\Microsoft\\FD56FF74-382C-3782-2A81-EC5BFE45E0BF&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C27D</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">20602</span>C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>RegCreateKeyA<span style="color:#f92672">&gt;</span>]       <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C280</span> <span style="color:#f92672">|</span> FF15 <span style="color:#ae81ff">1</span>C602C <span style="color:#f92672">|</span> call <span style="color:#66d9ef">dword</span> ptr ds:[<span style="color:#f92672">&lt;&amp;</span>RegQueryValueExA<span style="color:#f92672">&gt;</span>]    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">6:52:26</span><span style="color:#a6e22e">.0547460</span> AM	rundll32.exe	<span style="color:#ae81ff">2800</span>	RegSetValue	HKCU<span style="color:#960050;background-color:#1e0010">\</span>Software<span style="color:#960050;background-color:#1e0010">\</span>AppDataLow<span style="color:#960050;background-color:#1e0010">\</span>Software<span style="color:#960050;background-color:#1e0010">\</span>Microsoft<span style="color:#960050;background-color:#1e0010">\</span>FD56FF74<span style="color:#f92672">-</span><span style="color:#ae81ff">382</span>C<span style="color:#f92672">-</span><span style="color:#ae81ff">3782</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>A81<span style="color:#f92672">-</span>EC5BFE45E0BF<span style="color:#960050;background-color:#1e0010">\</span>Client32	SUCCESS	Type: REG_BINARY, Length: <span style="color:#ae81ff">204</span>,<span style="color:#ae81ff">288</span>, Data: <span style="color:#ae81ff">96</span> F8 <span style="color:#ae81ff">2</span>A <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">2</span>F F1 C5 <span style="color:#ae81ff">2</span>F C9 E9 <span style="color:#ae81ff">60</span> <span style="color:#ae81ff">47</span> <span style="color:#ae81ff">5</span>E E2 FC <span style="color:#ae81ff">5</span>E
</span></span></code></pre></div><p>Here ursnif sets a few keys under AppDataLow for persistency.</p>
<p>After this, every string that was stored in the heap is released. These include the names of the registry keys, appdata, dropped DLL&rsquo;s name etc. Like mentioned before, ursnif tries to retrieve things dynamically as much as possible. At the end of the routine, it releases the heap memory. This leaves us with a very narrow window to peek into the strings.</p>
<p>After it copies itself under <code>%appdata%</code> and drops the keys at <code>appdatalow</code> key, ursnif attempts to <code>delete</code> itself. If it fails, it calls <code>MoveFileExW</code> with the argument <code>0x4</code>, which according to Microsoft&rsquo;s documentation corresponds to <code>MOVEFILE_DELAY_UNTIL_REBOOT</code>. Quoting from the documentation:</p>
<blockquote>
<p>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files.</p>
</blockquote>
<p><img loading="lazy" src="/assets/img/ursnif/9-delete.png" alt="Delete"  />
</p>
<p>Since this is the file we are currently executing from, <code>DeleteFileW</code> will fail and it will do this operation after the reboot.</p>
<h2 id="process-injection-a-nameprocessinjectiona">Process Injection <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#process-injection-a-nameprocessinjectiona">#</a></h2>
<p>Ursnif then calls a function to perform process injection.</p>
<p>Inside this function, a call is made to the <code>RtlGetNativeSystemInformation</code> API. Among other things, this is used to retrieve a list of running processes on the system.</p>
<p><img loading="lazy" src="/assets/img/ursnif/10-nativesysteminformation.png" alt="Nativesystem"  />

<code>esi</code> holds the address to the struct to be filled, which can be seen in the dump. Inside <code>381A3D</code>, a call is made to <code>002C346A</code>, which contains the process injection routine. This function takes the struct shown above as an argument.</p>
<p><img loading="lazy" src="/assets/img/ursnif/11-hashProcess.png" alt="hashprocess"  />

The above checks one of the struct members got from the undocumented call and if it is 0, it jumps to the end of the routine. ursnif uses this struct to retrieve a list of the running processes. It then enumerates these processes one by one, calculates the <code>checksum</code> of each process&rsquo; name, and compares them against the precalculated ones:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34B</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>D <span style="color:#ae81ff">121725</span>AC <span style="color:#f92672">|</span> cmp eax,AC251712                  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34B</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">74</span> <span style="color:#ae81ff">47</span>       <span style="color:#f92672">|</span> je <span style="color:#ae81ff">2</span>C3504                         <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34B</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>D <span style="color:#ae81ff">8</span>A8EFE58 <span style="color:#f92672">|</span> cmp eax,<span style="color:#ae81ff">58</span>FE8E8A                  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34C</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">74</span> <span style="color:#ae81ff">40</span>       <span style="color:#f92672">|</span> je <span style="color:#ae81ff">2</span>C3504                         <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34C</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>D <span style="color:#ae81ff">65496</span>DA7 <span style="color:#f92672">|</span> cmp eax,A76D4965                  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34C</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">74</span> <span style="color:#ae81ff">39</span>       <span style="color:#f92672">|</span> je <span style="color:#ae81ff">2</span>C3504                         <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34C</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>D <span style="color:#ae81ff">12</span>D72C96 <span style="color:#f92672">|</span> cmp eax,<span style="color:#ae81ff">962</span>CD712                  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34D</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">74</span> <span style="color:#ae81ff">32</span>       <span style="color:#f92672">|</span> je <span style="color:#ae81ff">2</span>C3504                         <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34D</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>D F5BBE0A6 <span style="color:#f92672">|</span> cmp eax,A6E0BBF5                  <span style="color:#f92672">|</span><span style="color:#75715e">;explorer.exe</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">002</span><span style="color:#a6e22e">C34D</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">75</span> <span style="color:#ae81ff">36</span>       <span style="color:#f92672">|</span> jne <span style="color:#ae81ff">2</span>C350F                        <span style="color:#f92672">|</span>
</span></span></code></pre></div><p>After looping through the process list, ursnif finally reaches <code>explorer.exe</code>, whose value corresponds to <code>A6E0BBF5</code>. I did not confirm this, but based on what I&rsquo;ve seen on other reports for this family, one of the other values might be for <code>svchost.exe</code>.</p>
<p>The jump takes us to another function call, which lets ursnif inject itself into <code>explorer.exe</code>. I was curious where the other jumps above would lead us to, and one of them seems to create a process. My guess is that if it does not find a suitable process to be injected, it creates one for itself.
<img loading="lazy" src="/assets/img/ursnif/12-process-create.png" alt="hashprocess"  />
</p>
<p>Continuing, ursnif calls <code>OpenProcess</code> to acquire a handle to <code>explorer.exe</code>. Then it makes a call to <code>GetProcAddress</code> with the handle of <code>explorer.exe</code> to get the address of <code>ntdll.RtlExitUserThread</code>.</p>
<p>Next, it calls <code>GetProcAddress</code> again. This time to get the address of <code>CreateRemoteThread</code>. And then, it calls <code>CreateRemoteThread</code>, with the <code>LPTHREAD_START_ROUTINE lpStartAddress</code> of <code>ntdll.RtlExitUserThread</code>. So, the injected thread will start executing from <code>RtlExitUserThread</code>. The thread is also created in <code>suspended</code> state.</p>
<p><img loading="lazy" src="/assets/img/ursnif/13-createthread.png" alt="createthread"  />
</p>
<p>After the thread is created, ursnif calls <code>ZwReadVirtualMemory</code> to read the first 4 bytes from the created thread&rsquo;s <code>EIP</code>. These 4 bytes are saved in a buffer. Ursnif then calls <code>VirtualProtectEx</code> to make the <code>page</code> from <code>RtlExitUserThread</code> writable. It uses <code>ZwWriteVirtualMemory</code> to write the bytes <code>EB FE CC CC</code> to the buffer, and resumes the thread.</p>
<p><code>EB FE</code> is quite a famous piece of opcode. It is an <code>infinite loop</code>, achieved by a relative short jump. Since short jumps takes 2 bytes, by jumping back 2 bytes, an infinite loop can be created. After the infinite loop, the next two bytes are <code>CC CC</code>, which are used for software breakpoints (more specifically, <code>debug exception handler</code>).</p>
<p>To sum up:</p>
<ol>
<li>Ursnif acquires a handle to <code>explorer.exe</code></li>
<li>From <code>explorer.exe</code>, gets address of <code>ntdll.RtlExitUserThread</code></li>
<li>Creates a suspended thread with EP set to <code>ntdll.RtlExitUserThread</code></li>
<li>Reads the first 4 bytes from the thread</li>
<li>Replaces the first 4 bytes from EP with <code>EBFECCCC</code>, which creates an infinite loop</li>
</ol>
<p>After seeing the disassembly for this function, I&rsquo;ve checked some of the material published on this malware family. In the blog referred below, the behavior listed above is described in pseudo-code.</p>
<blockquote>
<p><a href="https://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/">https://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/* source link above, copied from arielkoren.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">/* Obtain the process pid to inject to */</span>
</span></span><span style="display:flex;"><span>dwPID = GetInjectProcess()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hProcess = OpenProcess(dwPID, ...)
</span></span><span style="display:flex;"><span>pAddress = GetProcAddress(<span style="color:#e6db74">&#34;ntdll.dll&#34;</span>, <span style="color:#e6db74">&#34;RtlExitUserThread&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Create remote thread in suspended mode */</span>
</span></span><span style="display:flex;"><span>hThread = CreateRemoteThread(hProcess, 			<span style="color:#75715e">/* Remote process handle */</span>
</span></span><span style="display:flex;"><span>                            CREATE_SUSPENDED,	<span style="color:#75715e">/* creation flags */</span>
</span></span><span style="display:flex;"><span>                            pAddress,			<span style="color:#75715e">/* thread function address */</span>
</span></span><span style="display:flex;"><span>                            ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Read remote procedure first four bytes */</span>
</span></span><span style="display:flex;"><span>dwBackupData = ZwReadVirtualMemory(hProcess,	<span style="color:#75715e">/* Remote process handle */</span>
</span></span><span style="display:flex;"><span>								pAddress,		<span style="color:#75715e">/* Address to read */</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#ae81ff">4</span>,				<span style="color:#75715e">/* number of bytes to read */</span>
</span></span><span style="display:flex;"><span>                                ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Change address protection to `writable` */</span>
</span></span><span style="display:flex;"><span>VirtualProtectEx(hProcess,			<span style="color:#75715e">/* Remote process handle */</span>
</span></span><span style="display:flex;"><span>				READ_WRITE_EXECUTE,	<span style="color:#75715e">/* New protection flags */</span>
</span></span><span style="display:flex;"><span>				pAddress,			<span style="color:#75715e">/* Address to change protection on */</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ae81ff">4</span>,					<span style="color:#75715e">/* Size of address */</span>
</span></span><span style="display:flex;"><span>				...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ZwWriteVirtualMemory(hProcess,	<span style="color:#75715e">/* Remote process handle */</span>
</span></span><span style="display:flex;"><span>					pAddress,	<span style="color:#75715e">/* Address to overwrite */</span>
</span></span><span style="display:flex;"><span>					<span style="color:#ae81ff">0xCCCCFEEB</span>,	<span style="color:#75715e">/* Data to write */</span>
</span></span><span style="display:flex;"><span>					<span style="color:#ae81ff">4</span>,			<span style="color:#75715e">/* Size of data */</span>
</span></span><span style="display:flex;"><span>					...)
</span></span></code></pre></div><p>During my first analysis of ursnif, I noticed that a couple of seconds into the execution, CPU usage spiked to quite a high level, and the environment became almost unresponsive for a moment.</p>
<p>Looking at the screenshot below, I realized why. Since ursnif writes infinite loop at the entry point of <code>RtlExitUserThread</code>, whenever a user thread exited during this stage, it started running the infinite loop. This caused several threads to be in an infinite loop, draining a lof of CPU time. You can see that at least 4 threads have their EIP pointed at the infinite loop. However, only one of the threads&rsquo; EP points to the infinite loop, and it is suspended.</p>
<p><img loading="lazy" src="/assets/img/ursnif/14-newthread.png" alt="newthread"  />
</p>
<p>After this, ursnif resumes the thread for a short period for initialization, and suspends again. It calls <code>NtGetContextThread</code>, and uses the returned <code>struct</code> to modify the entry point of the thread. During the following routine, it calls</p>
<ul>
<li><code>ZwCreateSection</code></li>
<li><code>ZwMapViewOfSection</code></li>
<li><code>GetModuleHandleA</code></li>
<li><code>GetModuleFileNameW</code></li>
</ul>
<p>And then it uses these to retrieve addresses of <code>LdrLoadDll</code>, <code>LdrGetProcedureAddress</code>, and <code>ZwProtectVirtualMemory</code>. Ursnif then calls <code>ZwAllocateVirtualMemory</code> to allocate memory in explorer.exe&rsquo;s address space. In the screenshot below, the allocated address is <code>01FD0000</code>, and allocated space is <code>0x1000</code> bytes big.</p>
<p><img loading="lazy" src="/assets/img/ursnif/15-explorer-allocate.png" alt="explorersection"  />
</p>
<p>Ursnif then copies the payload to explorer&rsquo;s address space. In the screenshot below, the payload can be seen in dump:
<img loading="lazy" src="/assets/img/ursnif/16-payload-to-copy.png" alt="payloadtocopy"  />
</p>
<p>The disassembly of the payload looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">01</span><span style="color:#a6e22e">A193E</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">8</span>B48 <span style="color:#ae81ff">08</span>     <span style="color:#f92672">|</span> mov ecx,<span style="color:#66d9ef">dword</span> ptr ds:[eax<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>]       <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">01</span><span style="color:#a6e22e">A193E</span> <span style="color:#f92672">|</span> FF70 <span style="color:#ae81ff">10</span>     <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ds:[eax<span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>]         <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">01</span><span style="color:#a6e22e">A193E</span> <span style="color:#f92672">|</span> FF30        <span style="color:#f92672">|</span> push <span style="color:#66d9ef">dword</span> ptr ds:[eax]            <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">01</span><span style="color:#a6e22e">A193E</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">51</span>          <span style="color:#f92672">|</span> push ecx                           <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">01</span><span style="color:#a6e22e">A193E</span> <span style="color:#f92672">|</span> C3          <span style="color:#f92672">|</span> ret                                <span style="color:#f92672">|</span>
</span></span></code></pre></div><p>Since there is a <code>ret to push</code>, we will have to wait until the thread is executed to see where we will jump.</p>
<p>Ursnif then calls <code>ZwUnmapViewofSection</code> on a region with the size of <code>0x68000</code>. The section contains a 416KB PE file with erased header.</p>
<p>Continuing, ursnif calls <code>ZwWriteVirtualMemory</code> with the address of previously allocated space in explorer.exe, <code>01FD0000</code>, and the payload shown above.</p>
<p>Then ursnif calls <code>ZwSetContextThread</code>, with the new <code>EIP</code> written into the context. In the screenshot below, new <code>EIP</code> can be seen as <code>01FD0218</code>. Now we can attach to explorer.exe, set our breakpoint there, and let explorer.exe continue its execution.
<img loading="lazy" src="/assets/img/ursnif/17-context.png" alt="newcontext"  />
</p>
<p>Ursnif calls <code>ZwWriteVirtualMemory</code> again, this time to restore the previously overwritten 4 bytes; <code>EB FE CC CC</code>. It then calls <code>VirtualProtectEx</code> to restore the <code>page</code> rights. After this, process injection routine is finished, and ursnif calls <code>ResumeThread</code>.</p>
<h2 id="explorerexe-a-nameexplorera">explorer.exe <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#explorerexe-a-nameexplorera">#</a></h2>
<p>Immediately, our breakpoint at <code>01A193E</code> is triggered. The <code>push ecx, ret</code> routine takes the execution to another memory region, with the size <code>0x68000</code> (416KB). This is the PE file with erased header, previously used with <code>ZwUnmapViewOfSection</code>.</p>
<p>At this point, the analysis has become another side project that&rsquo;s waiting to see the light of day again. So that&rsquo;s it for this post. Who knows, maybe I can publish part 2 of this one day.</p>
<h2 id="ioc-a-nameidentifiersa">IOC <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#ioc-a-nameidentifiersa">#</a></h2>
<pre tabindex="0"><code>MD5: 75a86f64c1ab7d8a56532b793a8547b7
SHA256: 0f06bc2f24494d9206d8d985f0a2f13ec6975a225c0bdcbab6d7f74474ff70a6

File Access: c:\windows\system32\c_1252.nls
PDB String: c:\\path\\Know\\School\\Rest\\sing\\Pick\\officerun.pdb
File Write: %appdata%/Roaming/-RandomName-/-RandomName-.dll
Registry Write: HKCU\Software\Microsoft\Windows\CurrentVersion\Run
Registry Write: HKCU\Software\AppDataLow\Software\Microsoft\{GUID}
File Write: %temp%/[A-Fa-f0-9]{4}.bin
Network Data Format(Before Encryption): soft=%u&amp;version=%u&amp;user=%08x%08x%08x%08x&amp;server=%u&amp;id=%u&amp;crc=%x
Network Data Format(After Encryption): images/[encryted_data]/.[extension]
</code></pre><h2 id="references-and-further-reading-a-namereferencesa">References and Further Reading <!-- raw HTML omitted --><!-- raw HTML omitted --><a hidden class="anchor" aria-hidden="true" href="#references-and-further-reading-a-namereferencesa">#</a></h2>
<p><a href="https://forums.juniper.net/t5/Threat-Research/The-Gozi-Sleeper-Cell/ba-p/329691">https://forums.juniper.net/t5/Threat-Research/The-Gozi-Sleeper-Cell/ba-p/329691</a></p>
<p><a href="https://www.vmray.com/cyber-security-blog/analyzing-ursnif-behavior-malware-sandbox/">https://www.vmray.com/cyber-security-blog/analyzing-ursnif-behavior-malware-sandbox/</a></p>
<p><a href="https://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/">https://arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/</a></p>
<p><a href="https://www.netskope.com/blog/ursnif-data-theft-malware-shared-on-microsoft-onedrive">https://www.netskope.com/blog/ursnif-data-theft-malware-shared-on-microsoft-onedrive</a></p>
<p><a href="https://www.mbsd.jp/blog/20180607.html">https://www.mbsd.jp/blog/20180607.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ruysal.com/tags/Malware-Analysis/">Malware Analysis</a></li>
      <li><a href="https://ruysal.com/tags/Reverse-Engineering/">Reverse Engineering</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://ruysal.com"></a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
