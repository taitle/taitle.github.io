<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Answers to Page Table Exercises in xv6 - Taitlex</title>
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<meta property="og:title" content="Answers to Page Table Exercises in xv6">
<meta property="og:locale" content="en_US">
<meta name="description" content="xv6 Has a whole chapter dedicated to the Paging mechanism. Since the subject is presented extensively in the book, I won’t re-write it. Also, since xv6 is used as an actual course in many universities, I won’t be posting answers to the homework assignments, but rather I will post some of my solutions to the Exercise questions asked in the book, as I progress. I am referring to the Revision 10. 1. Look at real operating systems to see how they size memory. This question is answered thoroughly in the famous OSDev wiki. As it was stated in xv6, this really is a tricky thing to do in x86. Basically, our safest bet is to get the information from the BIOS. But how do we access to BIOS in protected mode, while the OS is running? http://wiki.osdev.org/Detecting_Memory_(x86) 3. Write a user program that grows its address space with 1 byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the pte for the new memory contain? To be able to investigate the page table easily, I wrote a system call which prints the page directory of the current process. Also, to understand some other problems I was curious about, I added a parameter to the system call, which acts like a switch and if it is set to 1, it prints the KERNEL pages, and if it is set to 0, it prints the USER pages. Here is the code: int sys_traverse(void){ struct proc *p = myproc(); pde_t *pgtab; int i, k, argument, flag = 0; if(argint(0, &amp;argument) &lt; 0){ cprintf(&quot;no argument passed.\n&quot;); return -1; } cprintf(&quot;p-&gt;name: %s\n&quot;, p-&gt;name); cprintf(&quot;p-&gt;pgdir: %x\n\n&quot;, p-&gt;pgdir); cprintf(&quot;argument: %d\n&quot;, argument); for( i = 0; i &lt; 1024; i++ ){ if( (p-&gt;pgdir)[i] &amp; PTE_P ){ //(a == 1) ? 20: 30 flag = 0; pgtab = (pte_t*)P2V(PTE_ADDR( (p-&gt;pgdir)[i] )); for( k = 0; k &lt; 1024; k ++){ if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ if(flag == 0){ cprintf(&quot;&amp;p-&gt;pgdir[%d]: %x, p-&gt;pgdir[%d]: %x\n&quot;, i, &amp;(p-&gt;pgdir)[i], i, (p-&gt;pgdir)[i] ); cprintf(&quot;\tpgtab starts at: %x and contains these entries:\n&quot;, pgtab); flag = 1; } cprintf(&quot;\t\t&amp;pgtab[%d]: %x, pgtab[%d]: %x\n&quot;, k, &amp;pgtab[k], k, pgtab[k]); } } } } return 0; } xv6 Does not set the PTE_U bit in Page Directory Entries. That means, we cannot check whether the table belongs to USER or KERNEL in PDEs. So, I had to check this in PTEs. Hence, I summoned this ugly creature from the one-liner hell. Lesson learned: Don’t hesitate to use nested ifs, this is much uglier. if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ The first condition checks whether the PTE is present, the second condition checks if the argument asks for USER pages (i.e 0). If we are looking for USER pages, we do bitwise and on pgtab[k] with PTE_U. Otherwise, we check whether the PGTAB contains PTE_U bit and negate it by checking against 0. Implementing the rest of the system call is unrelated to this post, so I will skip it. You can find some other blog posts detailing the necessary steps. Now that we have a system call to traverse the page table, we can answer the question. xv6 Allocates another page for a 1 byte sbrk call. You can see it in the screenshot below. 5. Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6. Before we get into the implementation of this, we need a script with a shebang line (#!/interp) so that it will be interpreted and we will be able to debug easily as we implement the code. In xv6’s main directory, I executed this to have a simple script with a visible result. cat &gt; script #!/sh echo hello; ls; Then, we need to modify the MAKEFILE so that this script is included in xv6’s filesystem. Find the following line and modify it as shown below: fs.img: mkfs README $(UPROGS) script ./mkfs fs.img README $(UPROGS) script Great. Now when we compile xv6, we will see a file named “script” in xv6’s filesystem. Implementing a shebang consists of two parts. First, we need to have this functionality present in our kernel. Only after that, user level programs can benefit from it and interpret the contents of the script. Since xv6 is a small system, only our beloved “sh” has the capability to interpret the script. To implement the functionality in the kernel, “exec.c” is our first stop. char shebang[3]; char interp_path[16]; //16 is for historical reasons. if(readi(ip, (char*)&amp;shebang, 0, sizeof(shebang)) != sizeof(shebang)) goto bad; shebang[2] = '\0'; if( shebang[0] == '#' &amp;&amp; shebang[1] == '!' ){ //cprintf(&quot;shebang: %s\n&quot;, shebang); readi(ip, (char*)&amp;interp_path, 2, sizeof(interp_path)); //cprintf(&quot;interp_path: %s\n&quot;, interp_path); for(i = 0; i &lt; sizeof(interp_path); i++){ if(interp_path[i] == 0xa){ interp_path[i] = '\0'; break; } } exec(interp_path, argv); } The code is pretty much self-explanatory. We read the first 3 bytes of the file into a buffer and check whether the file starts with “#!”. You might say “Hey, how do you know the file actually has 3 bytes? Won’t this cause some problems?” The answer is no because this functionality is implemented in “exec.c”, so we expect that the files that come here are either ELF files, whose header size is already bigger than 3 bytes, or script files, which start with “#!” bytes anyway. Later, we read the first 16 bytes into interp_path variable, starting from the second byte into the file. Again, you might ask “Why 16 bytes? The interpreter path might be longer!” That is correct. However, xv6 is a remake of the legendary UNIX v6, and traditionally, interpreter path was assumed as 16 bytes in the first implementations. You can check the history of it here: https://www.in-ulm.de/~mascheck/various/shebang/ One last thing, “0xa” is the newline in xv6, so it is used to separate commands from the shebang line. After that, we are done in “exec.c”, so we call “exec.c” itself, with interpreter path as the file to be executed, and the script as the argument. Since interpreter path is the first argument, which is what ip points to, first two bytes will not be “#!”, instead it will be the interpreter’s ELF binary. Now that we are done, let’s see the code we need to write in order to interpret the actual script content. if( (argc == 1) &amp; strcmp(argv[0], &quot;sh&quot;) ){ fd = open(argv[0], O_RDONLY); if( fd &lt; 0) printf(1, &quot;sh could not open: %s\n&quot;, argv[0]); read_bytes = read(fd, buf, sizeof(buf)); script_start = strchr(buf, 0xa); if( buf[read_bytes -1] == 0xa ) buf[read_bytes -1] = '\0'; if(fork1() == 0) runcmd(parsecmd(script_start)); wait(); exit(); } At first line, we are checking whether the program has only one arguments and whether it is &quot;sh&quot;, shell's name itself. If it is, we don't have any arguments, so this condition will not be met and sh will continue executing normally. Otherwise, we have an argument which needs to be interpreted. We just read the file and since the rest of the functionality we need is actually implemented in xv6 itself, we just copy it from there. One thing that I should mention is that I haven’t copied the code related to the “cd” command. If you want, you can copy it and modify the variables yourself. And this is all we need. Let’s just compile and run the script. The result is: 6. Delete the check if(ph.vaddr + ph.memsz &lt; ph.vaddr) in exec.c, and con- struct a user program that exploits that the check is missing. Even though this is the easiest question of all, I really liked this one. It perfectly demonstrates how an innocent looking integer overflow can be used to takeover the whole kernel. For this question, I used “ls” binary as the subject. To inspect how the program headers look lie on a normal “ls” binary, we can use “readelf -l _ls” in xv6’s main directory. The result is: So, on an innocent program, obviously (ph.vaddr + ph.memsz) will never be smaller than ph.vaddr. However, if we craft a program header like below, and the check does not exist, the address can be anything we want, including kernel’s addresses. That way, we can overwrite kernel’s pages, effectively taking over the system. You can modify the program header by opening it with a simple hex editor. I will not be showing how it is done, as there are already more than enough resources on that. This post has already turned out to be longer than I anticipated, but just a quick shout out to the people at MIT for preparing such a great content and making it available to the public. Also, much thanks to the UNIX gods for this amazing OS + and the almighty C :) Hope this post was as useful to you as it was to me. See you in another one.">
<meta property="og:description" content="xv6 Has a whole chapter dedicated to the Paging mechanism. Since the subject is presented extensively in the book, I won’t re-write it. Also, since xv6 is used as an actual course in many universities, I won’t be posting answers to the homework assignments, but rather I will post some of my solutions to the Exercise questions asked in the book, as I progress. I am referring to the Revision 10. 1. Look at real operating systems to see how they size memory. This question is answered thoroughly in the famous OSDev wiki. As it was stated in xv6, this really is a tricky thing to do in x86. Basically, our safest bet is to get the information from the BIOS. But how do we access to BIOS in protected mode, while the OS is running? http://wiki.osdev.org/Detecting_Memory_(x86) 3. Write a user program that grows its address space with 1 byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the pte for the new memory contain? To be able to investigate the page table easily, I wrote a system call which prints the page directory of the current process. Also, to understand some other problems I was curious about, I added a parameter to the system call, which acts like a switch and if it is set to 1, it prints the KERNEL pages, and if it is set to 0, it prints the USER pages. Here is the code: int sys_traverse(void){ struct proc *p = myproc(); pde_t *pgtab; int i, k, argument, flag = 0; if(argint(0, &amp;argument) &lt; 0){ cprintf(&quot;no argument passed.\n&quot;); return -1; } cprintf(&quot;p-&gt;name: %s\n&quot;, p-&gt;name); cprintf(&quot;p-&gt;pgdir: %x\n\n&quot;, p-&gt;pgdir); cprintf(&quot;argument: %d\n&quot;, argument); for( i = 0; i &lt; 1024; i++ ){ if( (p-&gt;pgdir)[i] &amp; PTE_P ){ //(a == 1) ? 20: 30 flag = 0; pgtab = (pte_t*)P2V(PTE_ADDR( (p-&gt;pgdir)[i] )); for( k = 0; k &lt; 1024; k ++){ if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ if(flag == 0){ cprintf(&quot;&amp;p-&gt;pgdir[%d]: %x, p-&gt;pgdir[%d]: %x\n&quot;, i, &amp;(p-&gt;pgdir)[i], i, (p-&gt;pgdir)[i] ); cprintf(&quot;\tpgtab starts at: %x and contains these entries:\n&quot;, pgtab); flag = 1; } cprintf(&quot;\t\t&amp;pgtab[%d]: %x, pgtab[%d]: %x\n&quot;, k, &amp;pgtab[k], k, pgtab[k]); } } } } return 0; } xv6 Does not set the PTE_U bit in Page Directory Entries. That means, we cannot check whether the table belongs to USER or KERNEL in PDEs. So, I had to check this in PTEs. Hence, I summoned this ugly creature from the one-liner hell. Lesson learned: Don’t hesitate to use nested ifs, this is much uglier. if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ The first condition checks whether the PTE is present, the second condition checks if the argument asks for USER pages (i.e 0). If we are looking for USER pages, we do bitwise and on pgtab[k] with PTE_U. Otherwise, we check whether the PGTAB contains PTE_U bit and negate it by checking against 0. Implementing the rest of the system call is unrelated to this post, so I will skip it. You can find some other blog posts detailing the necessary steps. Now that we have a system call to traverse the page table, we can answer the question. xv6 Allocates another page for a 1 byte sbrk call. You can see it in the screenshot below. 5. Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6. Before we get into the implementation of this, we need a script with a shebang line (#!/interp) so that it will be interpreted and we will be able to debug easily as we implement the code. In xv6’s main directory, I executed this to have a simple script with a visible result. cat &gt; script #!/sh echo hello; ls; Then, we need to modify the MAKEFILE so that this script is included in xv6’s filesystem. Find the following line and modify it as shown below: fs.img: mkfs README $(UPROGS) script ./mkfs fs.img README $(UPROGS) script Great. Now when we compile xv6, we will see a file named “script” in xv6’s filesystem. Implementing a shebang consists of two parts. First, we need to have this functionality present in our kernel. Only after that, user level programs can benefit from it and interpret the contents of the script. Since xv6 is a small system, only our beloved “sh” has the capability to interpret the script. To implement the functionality in the kernel, “exec.c” is our first stop. char shebang[3]; char interp_path[16]; //16 is for historical reasons. if(readi(ip, (char*)&amp;shebang, 0, sizeof(shebang)) != sizeof(shebang)) goto bad; shebang[2] = '\0'; if( shebang[0] == '#' &amp;&amp; shebang[1] == '!' ){ //cprintf(&quot;shebang: %s\n&quot;, shebang); readi(ip, (char*)&amp;interp_path, 2, sizeof(interp_path)); //cprintf(&quot;interp_path: %s\n&quot;, interp_path); for(i = 0; i &lt; sizeof(interp_path); i++){ if(interp_path[i] == 0xa){ interp_path[i] = '\0'; break; } } exec(interp_path, argv); } The code is pretty much self-explanatory. We read the first 3 bytes of the file into a buffer and check whether the file starts with “#!”. You might say “Hey, how do you know the file actually has 3 bytes? Won’t this cause some problems?” The answer is no because this functionality is implemented in “exec.c”, so we expect that the files that come here are either ELF files, whose header size is already bigger than 3 bytes, or script files, which start with “#!” bytes anyway. Later, we read the first 16 bytes into interp_path variable, starting from the second byte into the file. Again, you might ask “Why 16 bytes? The interpreter path might be longer!” That is correct. However, xv6 is a remake of the legendary UNIX v6, and traditionally, interpreter path was assumed as 16 bytes in the first implementations. You can check the history of it here: https://www.in-ulm.de/~mascheck/various/shebang/ One last thing, “0xa” is the newline in xv6, so it is used to separate commands from the shebang line. After that, we are done in “exec.c”, so we call “exec.c” itself, with interpreter path as the file to be executed, and the script as the argument. Since interpreter path is the first argument, which is what ip points to, first two bytes will not be “#!”, instead it will be the interpreter’s ELF binary. Now that we are done, let’s see the code we need to write in order to interpret the actual script content. if( (argc == 1) &amp; strcmp(argv[0], &quot;sh&quot;) ){ fd = open(argv[0], O_RDONLY); if( fd &lt; 0) printf(1, &quot;sh could not open: %s\n&quot;, argv[0]); read_bytes = read(fd, buf, sizeof(buf)); script_start = strchr(buf, 0xa); if( buf[read_bytes -1] == 0xa ) buf[read_bytes -1] = '\0'; if(fork1() == 0) runcmd(parsecmd(script_start)); wait(); exit(); } At first line, we are checking whether the program has only one arguments and whether it is &quot;sh&quot;, shell's name itself. If it is, we don't have any arguments, so this condition will not be met and sh will continue executing normally. Otherwise, we have an argument which needs to be interpreted. We just read the file and since the rest of the functionality we need is actually implemented in xv6 itself, we just copy it from there. One thing that I should mention is that I haven’t copied the code related to the “cd” command. If you want, you can copy it and modify the variables yourself. And this is all we need. Let’s just compile and run the script. The result is: 6. Delete the check if(ph.vaddr + ph.memsz &lt; ph.vaddr) in exec.c, and con- struct a user program that exploits that the check is missing. Even though this is the easiest question of all, I really liked this one. It perfectly demonstrates how an innocent looking integer overflow can be used to takeover the whole kernel. For this question, I used “ls” binary as the subject. To inspect how the program headers look lie on a normal “ls” binary, we can use “readelf -l _ls” in xv6’s main directory. The result is: So, on an innocent program, obviously (ph.vaddr + ph.memsz) will never be smaller than ph.vaddr. However, if we craft a program header like below, and the check does not exist, the address can be anything we want, including kernel’s addresses. That way, we can overwrite kernel’s pages, effectively taking over the system. You can modify the program header by opening it with a simple hex editor. I will not be showing how it is done, as there are already more than enough resources on that. This post has already turned out to be longer than I anticipated, but just a quick shout out to the people at MIT for preparing such a great content and making it available to the public. Also, much thanks to the UNIX gods for this amazing OS + and the almighty C :) Hope this post was as useful to you as it was to me. See you in another one.">
<link rel="canonical" href="taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/">
<meta property="og:url" content="taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/">
<meta property="og:site_name" content="Taitlex">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-11-19T02:15:02+03:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@https://twitter.com/taitlex">
<script type="application/ld+json">
{"name":null,"description":"xv6 Has a whole chapter dedicated to the Paging mechanism. Since the subject is presented extensively in the book, I won’t re-write it. Also, since xv6 is used as an actual course in many universities, I won’t be posting answers to the homework assignments, but rather I will post some of my solutions to the Exercise questions asked in the book, as I progress. I am referring to the Revision 10. 1. Look at real operating systems to see how they size memory. This question is answered thoroughly in the famous OSDev wiki. As it was stated in xv6, this really is a tricky thing to do in x86. Basically, our safest bet is to get the information from the BIOS. But how do we access to BIOS in protected mode, while the OS is running? http://wiki.osdev.org/Detecting_Memory_(x86) 3. Write a user program that grows its address space with 1 byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the pte for the new memory contain? To be able to investigate the page table easily, I wrote a system call which prints the page directory of the current process. Also, to understand some other problems I was curious about, I added a parameter to the system call, which acts like a switch and if it is set to 1, it prints the KERNEL pages, and if it is set to 0, it prints the USER pages. Here is the code: int sys_traverse(void){ struct proc *p = myproc(); pde_t *pgtab; int i, k, argument, flag = 0; if(argint(0, &amp;argument) &lt; 0){ cprintf(&quot;no argument passed.\\n&quot;); return -1; } cprintf(&quot;p-&gt;name: %s\\n&quot;, p-&gt;name); cprintf(&quot;p-&gt;pgdir: %x\\n\\n&quot;, p-&gt;pgdir); cprintf(&quot;argument: %d\\n&quot;, argument); for( i = 0; i &lt; 1024; i++ ){ if( (p-&gt;pgdir)[i] &amp; PTE_P ){ //(a == 1) ? 20: 30 flag = 0; pgtab = (pte_t*)P2V(PTE_ADDR( (p-&gt;pgdir)[i] )); for( k = 0; k &lt; 1024; k ++){ if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ if(flag == 0){ cprintf(&quot;&amp;p-&gt;pgdir[%d]: %x, p-&gt;pgdir[%d]: %x\\n&quot;, i, &amp;(p-&gt;pgdir)[i], i, (p-&gt;pgdir)[i] ); cprintf(&quot;\\tpgtab starts at: %x and contains these entries:\\n&quot;, pgtab); flag = 1; } cprintf(&quot;\\t\\t&amp;pgtab[%d]: %x, pgtab[%d]: %x\\n&quot;, k, &amp;pgtab[k], k, pgtab[k]); } } } } return 0; } xv6 Does not set the PTE_U bit in Page Directory Entries. That means, we cannot check whether the table belongs to USER or KERNEL in PDEs. So, I had to check this in PTEs. Hence, I summoned this ugly creature from the one-liner hell. Lesson learned: Don’t hesitate to use nested ifs, this is much uglier. if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){ The first condition checks whether the PTE is present, the second condition checks if the argument asks for USER pages (i.e 0). If we are looking for USER pages, we do bitwise and on pgtab[k] with PTE_U. Otherwise, we check whether the PGTAB contains PTE_U bit and negate it by checking against 0. Implementing the rest of the system call is unrelated to this post, so I will skip it. You can find some other blog posts detailing the necessary steps. Now that we have a system call to traverse the page table, we can answer the question. xv6 Allocates another page for a 1 byte sbrk call. You can see it in the screenshot below. 5. Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6. Before we get into the implementation of this, we need a script with a shebang line (#!/interp) so that it will be interpreted and we will be able to debug easily as we implement the code. In xv6’s main directory, I executed this to have a simple script with a visible result. cat &gt; script #!/sh echo hello; ls; Then, we need to modify the MAKEFILE so that this script is included in xv6’s filesystem. Find the following line and modify it as shown below: fs.img: mkfs README $(UPROGS) script ./mkfs fs.img README $(UPROGS) script Great. Now when we compile xv6, we will see a file named “script” in xv6’s filesystem. Implementing a shebang consists of two parts. First, we need to have this functionality present in our kernel. Only after that, user level programs can benefit from it and interpret the contents of the script. Since xv6 is a small system, only our beloved “sh” has the capability to interpret the script. To implement the functionality in the kernel, “exec.c” is our first stop. char shebang[3]; char interp_path[16]; //16 is for historical reasons. if(readi(ip, (char*)&amp;shebang, 0, sizeof(shebang)) != sizeof(shebang)) goto bad; shebang[2] = &#39;\\0&#39;; if( shebang[0] == &#39;#&#39; &amp;&amp; shebang[1] == &#39;!&#39; ){ //cprintf(&quot;shebang: %s\\n&quot;, shebang); readi(ip, (char*)&amp;interp_path, 2, sizeof(interp_path)); //cprintf(&quot;interp_path: %s\\n&quot;, interp_path); for(i = 0; i &lt; sizeof(interp_path); i++){ if(interp_path[i] == 0xa){ interp_path[i] = &#39;\\0&#39;; break; } } exec(interp_path, argv); } The code is pretty much self-explanatory. We read the first 3 bytes of the file into a buffer and check whether the file starts with “#!”. You might say “Hey, how do you know the file actually has 3 bytes? Won’t this cause some problems?” The answer is no because this functionality is implemented in “exec.c”, so we expect that the files that come here are either ELF files, whose header size is already bigger than 3 bytes, or script files, which start with “#!” bytes anyway. Later, we read the first 16 bytes into interp_path variable, starting from the second byte into the file. Again, you might ask “Why 16 bytes? The interpreter path might be longer!” That is correct. However, xv6 is a remake of the legendary UNIX v6, and traditionally, interpreter path was assumed as 16 bytes in the first implementations. You can check the history of it here: https://www.in-ulm.de/~mascheck/various/shebang/ One last thing, “0xa” is the newline in xv6, so it is used to separate commands from the shebang line. After that, we are done in “exec.c”, so we call “exec.c” itself, with interpreter path as the file to be executed, and the script as the argument. Since interpreter path is the first argument, which is what ip points to, first two bytes will not be “#!”, instead it will be the interpreter’s ELF binary. Now that we are done, let’s see the code we need to write in order to interpret the actual script content. if( (argc == 1) &amp; strcmp(argv[0], &quot;sh&quot;) ){ fd = open(argv[0], O_RDONLY); if( fd &lt; 0) printf(1, &quot;sh could not open: %s\\n&quot;, argv[0]); read_bytes = read(fd, buf, sizeof(buf)); script_start = strchr(buf, 0xa); if( buf[read_bytes -1] == 0xa ) buf[read_bytes -1] = &#39;\\0&#39;; if(fork1() == 0) runcmd(parsecmd(script_start)); wait(); exit(); } At first line, we are checking whether the program has only one arguments and whether it is &quot;sh&quot;, shell&#39;s name itself. If it is, we don&#39;t have any arguments, so this condition will not be met and sh will continue executing normally. Otherwise, we have an argument which needs to be interpreted. We just read the file and since the rest of the functionality we need is actually implemented in xv6 itself, we just copy it from there. One thing that I should mention is that I haven’t copied the code related to the “cd” command. If you want, you can copy it and modify the variables yourself. And this is all we need. Let’s just compile and run the script. The result is: 6. Delete the check if(ph.vaddr + ph.memsz &lt; ph.vaddr) in exec.c, and con- struct a user program that exploits that the check is missing. Even though this is the easiest question of all, I really liked this one. It perfectly demonstrates how an innocent looking integer overflow can be used to takeover the whole kernel. For this question, I used “ls” binary as the subject. To inspect how the program headers look lie on a normal “ls” binary, we can use “readelf -l _ls” in xv6’s main directory. The result is: So, on an innocent program, obviously (ph.vaddr + ph.memsz) will never be smaller than ph.vaddr. However, if we craft a program header like below, and the check does not exist, the address can be anything we want, including kernel’s addresses. That way, we can overwrite kernel’s pages, effectively taking over the system. You can modify the program header by opening it with a simple hex editor. I will not be showing how it is done, as there are already more than enough resources on that. This post has already turned out to be longer than I anticipated, but just a quick shout out to the people at MIT for preparing such a great content and making it available to the public. Also, much thanks to the UNIX gods for this amazing OS + and the almighty C :) Hope this post was as useful to you as it was to me. See you in another one.","author":null,"@type":"BlogPosting","url":"taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/","publisher":null,"image":null,"headline":"Answers to Page Table Exercises in xv6","dateModified":"2017-11-19T02:15:02+03:00","datePublished":"2017-11-19T02:15:02+03:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
  <link rel="alternate" type="application/rss+xml" title="Taitlex" href="taitle.github.io/feed.xml">
  <link rel="stylesheet" href="/assets/css/nangka.css">

  

</head>

  <body>
    <header class="site-header">
    <div class="wrapper">
        <a href="#" class="menu-icon">
            <svg viewbox="0 0 18 15">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
            </svg>
        </a>
        <a class="site-title" href="/">Taitlex</a>
        <nav class="site-nav">
            <div class="trigger">
            
                
            
                
                        <a class="page-link" href="/about/">About</a>
                
            
                
                        <a class="page-link" href="/archive/">Archive</a>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
            </div>
        </nav>
    </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Answers to Page Table Exercises in xv6</h1>
    <p class="post-meta">
       <time datetime="2017-11-19T02:15:02+03:00" itemprop="datePublished">
          Nov 19, 2017
       </time>
       
        | <span class="time">
            8
          </span>
           Minute Read
    </p>
  </header>
  <div class="post-content" itemprop="articleBody">
    <p>xv6 Has a whole chapter dedicated to the Paging mechanism. Since the subject is presented extensively in the book, I won’t re-write it. Also, since xv6 is used as an actual course in many universities, I won’t be posting answers to the homework assignments, but rather I will post some of my solutions to the Exercise questions asked in the book, as I progress. I am referring to the Revision 10.</p>

<blockquote>
  <p><strong>1. Look at real operating systems to see how they size memory.</strong></p>
</blockquote>

<p>This question is answered thoroughly in the famous OSDev wiki.  As it was stated in xv6, this really is a tricky thing to do in x86. Basically, our safest bet is to get the information from the BIOS. But how do we access to BIOS in protected mode, while the OS is running?
http://wiki.osdev.org/Detecting_Memory_(x86)</p>

<blockquote>
  <p><strong>3. Write a user program that grows its address space with 1 byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the pte for the new memory contain?</strong></p>
</blockquote>

<p>To be able to investigate the page table easily, I wrote a system call which prints the page directory of the current process. Also, to understand some other problems I was curious about, I added a parameter to the system call, which acts like a switch and if it is set to 1, it prints the KERNEL pages, and if it is set to 0, it prints the USER pages. Here is the code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sys_traverse(void){
struct proc *p = myproc();

pde_t *pgtab;
int i, k, argument, flag = 0;

if(argint(0, &amp;argument) &lt; 0){
	cprintf("no argument passed.\n");
	return -1;
}

cprintf("p-&gt;name: %s\n", p-&gt;name);
cprintf("p-&gt;pgdir: %x\n\n", p-&gt;pgdir);
cprintf("argument: %d\n", argument);

for( i = 0; i &lt; 1024; i++ ){
	if( (p-&gt;pgdir)[i] &amp; PTE_P ){ //(a == 1) ? 20: 30
		flag = 0;
		pgtab = (pte_t*)P2V(PTE_ADDR( (p-&gt;pgdir)[i] ));
		
		for( k = 0; k &lt; 1024; k ++){
			if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){
				if(flag == 0){
					cprintf("&amp;p-&gt;pgdir[%d]: %x, p-&gt;pgdir[%d]: %x\n", i, &amp;(p-&gt;pgdir)[i], i, (p-&gt;pgdir)[i] );
					cprintf("\tpgtab starts at: %x and contains these entries:\n", pgtab);
					flag = 1;
				}
				cprintf("\t\t&amp;pgtab[%d]: %x, pgtab[%d]: %x\n", k, &amp;pgtab[k], k, pgtab[k]);
			}
		} 
	}
}
return 0; }
</code></pre></div></div>

<p>xv6 Does not set the PTE_U bit in Page Directory Entries. That means, we cannot check whether the table belongs to USER or KERNEL in PDEs. So, I had to check this in PTEs. Hence, I summoned this ugly creature from the one-liner hell. Lesson learned: Don’t hesitate to use nested ifs, this is much  uglier.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if( pgtab[k] &amp; PTE_P &amp;&amp; pgtab[k] &amp; ( (argument == 0) ? PTE_U: ( (pgtab[k] &amp; PTE_U) == 0) ) ){
</code></pre></div></div>

<p>The first condition checks whether the PTE is present, the second condition checks if the argument asks for USER pages (i.e 0). If we are looking for USER pages, we do bitwise and on pgtab[k] with PTE_U. Otherwise, we check whether the PGTAB contains PTE_U bit and negate it by checking against 0.</p>

<p>Implementing the rest of the system call is unrelated to this post, so I will skip it. You can find some other blog posts detailing the necessary steps.</p>

<p>Now that we have a system call to traverse the page table, we can answer the question. xv6 Allocates another page for a 1 byte sbrk call. You can see it in the screenshot below.</p>

<p><img src="http://oi65.tinypic.com/dmw9wh.jpg" alt="Exercise 3"></p>

<blockquote>
  <p><strong>5. Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6.</strong></p>
</blockquote>

<p>Before we get into the implementation of this, we need a script with a shebang line (#!/interp) so that it will be interpreted and we will be able to debug easily as we implement the code. In xv6’s main directory, I executed this to have a simple script with a visible result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; script
#!/sh
echo hello;
ls;
</code></pre></div></div>

<p>Then, we need to modify the MAKEFILE so that this script is included in xv6’s filesystem. Find the following line and modify it as shown below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fs.img: mkfs README $(UPROGS) script
./mkfs fs.img README $(UPROGS) script
</code></pre></div></div>

<p>Great. Now when we compile xv6, we will see a file named “script” in xv6’s filesystem.</p>

<p>Implementing a shebang consists of two parts. First, we need to have this functionality present in our kernel. Only after that, user level programs can benefit from it and interpret the contents of the script. Since xv6 is a small system, only our beloved “sh” has the capability to interpret the script. To implement the functionality in the kernel, “exec.c” is our first stop.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char shebang[3];
char interp_path[16]; //16 is for historical reasons. 

if(readi(ip, (char*)&amp;shebang, 0, sizeof(shebang)) != sizeof(shebang)) 
  goto bad;

shebang[2] = '\0';

if( shebang[0] == '#' &amp;&amp; shebang[1] == '!' ){
  //cprintf("shebang: %s\n", shebang);
  
  readi(ip, (char*)&amp;interp_path, 2, sizeof(interp_path));
  //cprintf("interp_path: %s\n", interp_path);
  for(i = 0; i &lt; sizeof(interp_path); i++){
	  if(interp_path[i] == 0xa){
		interp_path[i] = '\0';
		break;
	  }
  }
  exec(interp_path, argv);
}
</code></pre></div></div>

<p>The code is pretty much self-explanatory. We read the first 3 bytes of the file into a buffer and check whether the file starts with “#!”.</p>

<p>You might say “Hey, how do you know the file actually has 3 bytes? Won’t this cause some problems?” The answer is no because this functionality is implemented in “exec.c”, so we expect that the files that come here are either ELF files, whose header size is already bigger than 3 bytes, or script files, which start with “#!” bytes anyway.</p>

<p>Later, we read the first 16 bytes into interp_path variable, starting from the second byte into the file. Again, you might ask “Why 16 bytes? The interpreter path might be longer!” That is correct. However, xv6 is a remake of the legendary UNIX v6, and traditionally, interpreter path was assumed as 16 bytes in the first implementations. You can check the history of it here:
https://www.in-ulm.de/~mascheck/various/shebang/</p>

<p>One last thing, “0xa” is the newline in xv6, so it is used to separate commands from the shebang line. After that, we are done in “exec.c”, so we call “exec.c” itself, with interpreter path as the file to be executed, and the script as the argument. Since interpreter path is the first argument, which is what ip points to, first two bytes will not be “#!”, instead it will be the interpreter’s ELF binary.</p>

<p>Now that we are done, let’s see the code we need to write in order to interpret the actual script content.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if( (argc == 1) &amp; strcmp(argv[0], "sh") ){
fd = open(argv[0], O_RDONLY);
if( fd &lt; 0)
	printf(1, "sh could not open: %s\n", argv[0]);

read_bytes = read(fd, buf, sizeof(buf));
script_start = strchr(buf, 0xa);

if( buf[read_bytes -1] == 0xa )
	buf[read_bytes -1] = '\0';

if(fork1() == 0)
  runcmd(parsecmd(script_start));
wait();
exit();
} At first line, we are checking whether the program has only one arguments and whether it is "sh", shell's name itself. If it is, we don't have any arguments, so this condition will not be met and sh will continue executing normally. Otherwise, we have an argument which needs to be interpreted. We just read the file and since the rest of the functionality we need is actually implemented in xv6 itself, we just copy it from there.
</code></pre></div></div>

<p>One thing that I should mention is that I haven’t copied the code related to the “cd” command. If you want, you can copy it and modify the variables yourself.</p>

<p>And this is all we need. Let’s just compile and run the script. The result is:</p>

<p><img src="http://oi68.tinypic.com/14250mx.jpg" alt="xv6shebang"></p>

<blockquote>
  <p><strong>6. Delete the check if(ph.vaddr + ph.memsz &lt; ph.vaddr) in exec.c, and con- struct a user program that exploits that the check is missing.</strong></p>
</blockquote>

<p>Even though this is the easiest question of all, I really liked this one. It perfectly demonstrates how an innocent looking integer overflow can be used to takeover the whole kernel. For this question, I used “ls” binary as the subject. To inspect how the program headers look lie on a normal “ls” binary, we can use “readelf -l _ls” in xv6’s main directory. The result is:</p>

<p><img src="http://oi68.tinypic.com/jg2uxw.jpg" alt="innocent ls"></p>

<p>So, on an innocent program, obviously (ph.vaddr + ph.memsz) will never be smaller than ph.vaddr. However, if we craft a program header like below, and the check does not exist, the address can be anything we want, including kernel’s addresses. That way, we can overwrite kernel’s pages, effectively taking over the system.</p>

<p><img src="http://oi67.tinypic.com/2r70w06.jpg" alt="evil ls"></p>

<p>You can modify the program header by opening it with a simple hex editor. I will not be showing how it is done, as there are already more than enough resources on that.</p>

<p>This post has already turned out to be longer than I anticipated, but just a quick shout out to the people at MIT for preparing such a great content and making it available to the public. Also, much thanks to the UNIX gods for this amazing OS  + and the almighty C :)</p>

<p>Hope this post was as useful to you as it was to me. See you in another one.</p>


  </div>
  <footer class="post-footer">

    <!-- Social Share Button-->
    <ul class="sharebutton">
      <li class="share">Share :</li>
      <li class="linkedin">
        <a href="http://www.linkedin.com/cws/share?url=taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/" onclick='window.open(this.href,"popupwindow","status=0,height=500,width=700,resizable=0,top=50,left=100");return false;' target="_blank" title="Share on Linkedin">Linkedin</a>
      </li>
      <li class="twitter">
        <a href="https://twitter.com/intent/tweet?text=taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/%20-%20Answers%20to%20Page%20Table%20Exercises%20in%20xv6%20by%20@https://twitter.com/taitlex" target="_blank" title="Share to Twitter">Twitter</a>
      </li>
      <li class="gplus">
        <a href="https://plus.google.com/share?url=taitle.github.io/2017/answers-to-page-table-exercises-in-xv6/" onclick='window.open(this.href,"popupwindow","status=0,height=500,width=700,resizable=0,top=50,left=100");return false;' target="_blank" title="Share on Google Plus">Google+</a>
    </li>
</ul>

    <!-- Post Navigation -->
    <div class="post-navigation">
      
      
    </div>
      

  </footer>
</article>

      </div>
    </div>
    <footer class="site-footer">
  <div class="wrapper">
      <div class="copy">
          2017 © Taitlex
      </div>
  </div>
</footer>

    <script type="text/javascript" src="/assets/js/jquery-1.11.2.min.js"></script>

<script type="text/javascript" src="/assets/js/scripts.js"></script>

  </body>
</html>
